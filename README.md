# CS320-T1023_Software_Test_Automation_QA
 A journal entry for software testing, automation, and quality assurance.

How can I ensure that my code, program, or software is functional and secure?
I ensure that my code, program, or software is functional by designing the program with testing in mind. For this program in particular, utilizing software testing techniques such as boundary value analysis and state transitions proved critical in achieving over 92% coverage across the Contact Service, Task Service, and Appointment Service requirements. Additionally, to ensure my code, program, or software is secure, I approach the program with somewhat of a pessimistic perspective such that I avoid bias by assuming there are loopholes and/or bugs that I need to find. Therefore, I need to perform thorough testing to make sure my tests are reaching the inner depths of my code and that conditions are written in a way that disallows unexpected inputs. Overall, as the programs become more complex, I will utilize appropriate tools and techniques based on the requirements to further ensure my software is functional and secure.

How do I interpret user needs and incorporate them into a program?
I interpret user needs as the strict requirements in the composition of a program that act as the cornerstone of the final product. Any changes to these requirements should be communicated to the user before being incorporated into a program. Furthermore, all requirements should be static tested before making it to the development stage because the earlier an issue with requirements is caught, the cheaper and easier it is to fix. Likewise, requirements should face rigorous dynamic testing once the development makes it that far. Most importantly, user needs should be the dictatorship of the software development life cycle.

How do I approach designing software?
I approach designing software with the mentality of "What are the client requirements?". Once the requirements were gathered and established, I would adopt the mentality of looking at what the ultimate objective is--I would call this the 'big problem' being solved. I would then break this problem into smaller and smaller problems until I reach the point where each function serves a single purpose within reason. This process would closely adhere to the client requirements. I would look at the practicality and logic of the design to determine the best practices, language(s), collaboration tools, framework(s), development environment(s), and any other tools or resources I might need. As a part of this decision process, I would decide what type of testing is needed, whether there should be any automation and, if so, what type of automation, how the entire system should interconnect, what user stories will look like, and how to modularize my code in order to make it easy to reuse and maintain. Ultimately, designing software should be approached with patience because taking the time to design will save valuable time, costs, and headache in the long run.
